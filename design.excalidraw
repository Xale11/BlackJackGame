{
  "type": "excalidraw",
  "version": 2,
  "source": "https://marketplace.visualstudio.com/items?itemName=pomdtr.excalidraw-editor",
  "elements": [
    {
      "type": "text",
      "version": 23,
      "versionNonce": 700044185,
      "isDeleted": false,
      "id": "TxnANdqDeJHncFO-E5kW2",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 289.6000061035156,
      "y": 187.80003356933594,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 91.001953125,
      "height": 45,
      "seed": 2072067527,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1735853184758,
      "link": null,
      "locked": false,
      "fontSize": 36,
      "fontFamily": 5,
      "text": "Ideas:",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "Ideas:",
      "lineHeight": 1.25,
      "baseline": 38
    },
    {
      "type": "text",
      "version": 979,
      "versionNonce": 1177652855,
      "isDeleted": false,
      "id": "-wWfth-i5UQ3axFFu_VLk",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 294.3999938964844,
      "y": 268.20001220703125,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 750.595703125,
      "height": 500,
      "seed": 1892800713,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1735853184758,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 5,
      "text": "- 1 v 1: Simply the user vs. a computer (Dealer)\n\n- 1 v 3: 2 other computers and an a Dealer (also COM)\n\n- 1 v 1: with option to be dealer or player (Not sure if this \nfits the scenarios)\n\n- 1 v 1 as a way to learn the game (tutorial mode), then a 1 v 3 is an actual game\n\n- Multiplayer but (COM) dealer. Room based. Max 3 per room.\n\n- Options between tutorial, 1 v 1 with COM or multiplayer\n\n- Allow for addition and subtraction to get 21. You lose if you get over 5 cards.\n\n- simultaneous games running, multiple hands at once\n\n- in concurrent games, if you win 2 games before all games are done there can be \na rule change e.g. remove a card, add and subtract, pick up a card and put back if not\nwanted. ",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "- 1 v 1: Simply the user vs. a computer (Dealer)\n\n- 1 v 3: 2 other computers and an a Dealer (also COM)\n\n- 1 v 1: with option to be dealer or player (Not sure if this \nfits the scenarios)\n\n- 1 v 1 as a way to learn the game (tutorial mode), then a 1 v 3 is an actual game\n\n- Multiplayer but (COM) dealer. Room based. Max 3 per room.\n\n- Options between tutorial, 1 v 1 with COM or multiplayer\n\n- Allow for addition and subtraction to get 21. You lose if you get over 5 cards.\n\n- simultaneous games running, multiple hands at once\n\n- in concurrent games, if you win 2 games before all games are done there can be \na rule change e.g. remove a card, add and subtract, pick up a card and put back if not\nwanted. ",
      "lineHeight": 1.25,
      "baseline": 496
    },
    {
      "type": "text",
      "version": 104,
      "versionNonce": 441317497,
      "isDeleted": false,
      "id": "HPEJudiip_Dl4iecHWDBi",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 1228.508835404008,
      "y": 167.314815097385,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 375.6796875,
      "height": 45,
      "seed": 33336071,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1735853184758,
      "link": null,
      "locked": false,
      "fontSize": 36,
      "fontFamily": 5,
      "text": "Possible Card Interfaces",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "Possible Card Interfaces",
      "lineHeight": 1.25,
      "baseline": 38
    },
    {
      "type": "text",
      "version": 1724,
      "versionNonce": 1946593175,
      "isDeleted": false,
      "id": "sH1wrdbdy_oWuOdYmPolg",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 1233.3088231969768,
      "y": 247.71479373508032,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 1024.345703125,
      "height": 700,
      "seed": 1600107047,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1735853184758,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 5,
      "text": "interface Card {\n    suit: \"clubs\" | \"spades\" | \"hearts\" | \"diamonds\" // might not be needed\n    value: string | number  // use typeof to determine how to hand calculation of value\n    cardId: string\n    imageUrl: string  // rather than needing suits just have an image attached to each cardId that shows a suit on it     \n}\n\ninterface Card {\n    cardId: string\n    imageUrl: string  // rather than needing suits just have an image attached to each cardId that shows a suit on it  \n    maxVal: number\n    minVal: number // will be the same as maxVal unless ace   \n}\n\n// I need to determine how to calculate the total when aces are present before I can settle on type for a card\n\n\n// final object\ninterface Card {\n    cardId: string // makes a card unique. players cannot have dupe cards\n    imageUrl: string  // suits are irrelevant to the logic. Just need unique images with images of the suits\n    value: number[] // after seeing how to calculate the total a number array is best   \n}\n\nInterface Deck {\n    cards: Card[]\n}\n",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "interface Card {\n    suit: \"clubs\" | \"spades\" | \"hearts\" | \"diamonds\" // might not be needed\n    value: string | number  // use typeof to determine how to hand calculation of value\n    cardId: string\n    imageUrl: string  // rather than needing suits just have an image attached to each cardId that shows a suit on it     \n}\n\ninterface Card {\n    cardId: string\n    imageUrl: string  // rather than needing suits just have an image attached to each cardId that shows a suit on it  \n    maxVal: number\n    minVal: number // will be the same as maxVal unless ace   \n}\n\n// I need to determine how to calculate the total when aces are present before I can settle on type for a card\n\n\n// final object\ninterface Card {\n    cardId: string // makes a card unique. players cannot have dupe cards\n    imageUrl: string  // suits are irrelevant to the logic. Just need unique images with images of the suits\n    value: number[] // after seeing how to calculate the total a number array is best   \n}\n\nInterface Deck {\n    cards: Card[]\n}\n",
      "lineHeight": 1.25,
      "baseline": 696
    },
    {
      "type": "text",
      "version": 183,
      "versionNonce": 852132185,
      "isDeleted": false,
      "id": "riPGjvx1O1xdXtVOhw7p1",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 249.087819417319,
      "y": 1010.6482501559786,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 665.05078125,
      "height": 45,
      "seed": 1471993097,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1735853184758,
      "link": null,
      "locked": false,
      "fontSize": 36,
      "fontFamily": 5,
      "text": "How calculate total when aces are present",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "How calculate total when aces are present",
      "lineHeight": 1.25,
      "baseline": 38
    },
    {
      "type": "text",
      "version": 2273,
      "versionNonce": 370908343,
      "isDeleted": false,
      "id": "W78SK8AvbSQbDyntMBLO1",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 253.88780721028775,
      "y": 1091.0482287936738,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 565.576171875,
      "height": 625,
      "seed": 894389225,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1735853184758,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 5,
      "text": "nine + ace + ace:\n9 + 1 + 1 = 11\n9+11+1=21\n9+11+11=31\n\nUse an array and loop through each combination\n[9] + [1, 11] + [1, 11]\n\na function that takes 2 arrays of values and adds its combination\ntogether and outputs a new array of every possible output\n\ne.g. the first addition or 1 card that is an ace\n\nres = combinator([0], [1, 11])\nres = [1, 11]\n\ne.g. ace and 9\n\nres = combinator([1,11], [9])\nres = [10, 20]\n\nSeems like a good way of reducing complexity. Rather than\ntrying to compute all at once.\n\nIterate through each card and store the value. Then set the total",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "nine + ace + ace:\n9 + 1 + 1 = 11\n9+11+1=21\n9+11+11=31\n\nUse an array and loop through each combination\n[9] + [1, 11] + [1, 11]\n\na function that takes 2 arrays of values and adds its combination\ntogether and outputs a new array of every possible output\n\ne.g. the first addition or 1 card that is an ace\n\nres = combinator([0], [1, 11])\nres = [1, 11]\n\ne.g. ace and 9\n\nres = combinator([1,11], [9])\nres = [10, 20]\n\nSeems like a good way of reducing complexity. Rather than\ntrying to compute all at once.\n\nIterate through each card and store the value. Then set the total",
      "lineHeight": 1.25,
      "baseline": 621
    },
    {
      "type": "text",
      "version": 245,
      "versionNonce": 545451577,
      "isDeleted": false,
      "id": "2u2hwejnhpoqeU854AnWC",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 2880,
      "y": 157.1895510647712,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 397.6171875,
      "height": 45,
      "seed": 923236265,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1735853184758,
      "link": null,
      "locked": false,
      "fontSize": 36,
      "fontFamily": 5,
      "text": "Possible Player Interfaces",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "Possible Player Interfaces",
      "lineHeight": 1.25,
      "baseline": 38
    },
    {
      "type": "text",
      "version": 3277,
      "versionNonce": 1343548887,
      "isDeleted": false,
      "id": "bfLF3g96fKsvI91Q3unDW",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 2884.7999877929688,
      "y": 237.5895297024665,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 604.716796875,
      "height": 1200,
      "seed": 611097225,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1735853184758,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 5,
      "text": "interface Player {\n    hand: Card[]\n    possibleScores: number[] \n    isDealer: boolean // I might have a sperate dealer object   \n    playerId: number or string // a way to uniquely identify a player\n    name: string // nice touch if I add a multiplayer mode\n    hit: ()  => void // not sure of the output\n    stand: () => void // not sure of output\n    evaluate: () => number\n    isBust: boolean \n}\n\n// I had forgot included the Deck interface, so I'm remaking interface\n\nRequirements:\n- Be able to hold multiple cards from the Deck\n- Be only able to take cards from the deck (Deck must update)\n- Choose to Hit/ draw a card\n- Choose to stand\n- See their hand\n- See opposing players hand when rules allow\n- Specify wether they are dealer or not\n- See their possible scores live\n- Be able to know their game status e.g. bust, win, draw\n- Be able to see who won\n- Be able to see scores of other players\n- Be able to see who go it is\n- Only play when it is their go\n- See final score when the game is over\n- How much money/points they earned -- later implementation\n\n\ninterface Player {\n    hand: Card[]\n    possibleScores: number[] \n    calculatePossibleScores: () => number[\n    isDealer: boolean // I might have a sperate dealer object   \n    playerId: number or string // a way to uniquely identify a player\n    name?: string // nice touch if I add a multiplayer mode\n    hit: ()  => void // not sure of the output\n    stand: () => void // not sure of output\n    evaluate: () => number\n    isBust: boolean \n    isWinner?: boolean\n}\n\n\n",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "interface Player {\n    hand: Card[]\n    possibleScores: number[] \n    isDealer: boolean // I might have a sperate dealer object   \n    playerId: number or string // a way to uniquely identify a player\n    name: string // nice touch if I add a multiplayer mode\n    hit: ()  => void // not sure of the output\n    stand: () => void // not sure of output\n    evaluate: () => number\n    isBust: boolean \n}\n\n// I had forgot included the Deck interface, so I'm remaking interface\n\nRequirements:\n- Be able to hold multiple cards from the Deck\n- Be only able to take cards from the deck (Deck must update)\n- Choose to Hit/ draw a card\n- Choose to stand\n- See their hand\n- See opposing players hand when rules allow\n- Specify wether they are dealer or not\n- See their possible scores live\n- Be able to know their game status e.g. bust, win, draw\n- Be able to see who won\n- Be able to see scores of other players\n- Be able to see who go it is\n- Only play when it is their go\n- See final score when the game is over\n- How much money/points they earned -- later implementation\n\n\ninterface Player {\n    hand: Card[]\n    possibleScores: number[] \n    calculatePossibleScores: () => number[\n    isDealer: boolean // I might have a sperate dealer object   \n    playerId: number or string // a way to uniquely identify a player\n    name?: string // nice touch if I add a multiplayer mode\n    hit: ()  => void // not sure of the output\n    stand: () => void // not sure of output\n    evaluate: () => number\n    isBust: boolean \n    isWinner?: boolean\n}\n\n\n",
      "lineHeight": 1.25,
      "baseline": 1196
    },
    {
      "type": "text",
      "version": 312,
      "versionNonce": 442154777,
      "isDeleted": false,
      "id": "Y7DCsM6wFGnNSGeZ3MjFp",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 3669.8676958969727,
      "y": 140,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 394.681640625,
      "height": 45,
      "seed": 1126917799,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1735853184758,
      "link": null,
      "locked": false,
      "fontSize": 36,
      "fontFamily": 5,
      "text": "Possible Game Interfaces",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "Possible Game Interfaces",
      "lineHeight": 1.25,
      "baseline": 38
    },
    {
      "type": "text",
      "version": 3579,
      "versionNonce": 1560746743,
      "isDeleted": false,
      "id": "E0RKhFuy-6WmnGHJjuPNy",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 3674.6676836899414,
      "y": 220.3999786376953,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 916.19140625,
      "height": 1075,
      "seed": 1853225415,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1735853184758,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 5,
      "text": "interface Game {\n    startGame: () => void\n    isGameOn: boolean\n    endGame: () => void\n    generateDeck: () => void\n    deck: Card[] e.g. Deck\n    players: Player[]\n    shuffle: (deck: Deck) => Deck\n    shufflePlayers{ players: Player[] => Player[]\n    evaluatePlayers: () => void\n}\n\n// I had forgot included the Deck interface, so I'm remaking interface\n\nRequirements:\n- start a game\n- pause a game\n- end a game\n- know the status of the game\n- show the cards being played\n- show and know the current player playing\n- Declare end game outcome of players e.g. win, lose, draw\n- Adhere to the rules of the game\n- enforce the rules of the game\n- handle the players and deck\n- know when to end the game and declare winners\n- control flow of the game\n- set up a game will all required components\n\ninterface Game {\n    startGame: () => void\n    isGameOn: boolean\n    endGame: () => void\n    players: Player[]\n    currentPlayer: Player\n    nextPlayer: () => void // contains game logic also - cycles to next player then lets them execute a play\n    getResults: () => void\n    checkGameStatus: () => void // checks if the game should end due to 21 score\n    setUpGame: () => void\n    }\n\n\n1 > 2 > 3> 4",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "interface Game {\n    startGame: () => void\n    isGameOn: boolean\n    endGame: () => void\n    generateDeck: () => void\n    deck: Card[] e.g. Deck\n    players: Player[]\n    shuffle: (deck: Deck) => Deck\n    shufflePlayers{ players: Player[] => Player[]\n    evaluatePlayers: () => void\n}\n\n// I had forgot included the Deck interface, so I'm remaking interface\n\nRequirements:\n- start a game\n- pause a game\n- end a game\n- know the status of the game\n- show the cards being played\n- show and know the current player playing\n- Declare end game outcome of players e.g. win, lose, draw\n- Adhere to the rules of the game\n- enforce the rules of the game\n- handle the players and deck\n- know when to end the game and declare winners\n- control flow of the game\n- set up a game will all required components\n\ninterface Game {\n    startGame: () => void\n    isGameOn: boolean\n    endGame: () => void\n    players: Player[]\n    currentPlayer: Player\n    nextPlayer: () => void // contains game logic also - cycles to next player then lets them execute a play\n    getResults: () => void\n    checkGameStatus: () => void // checks if the game should end due to 21 score\n    setUpGame: () => void\n    }\n\n\n1 > 2 > 3> 4",
      "lineHeight": 1.25,
      "baseline": 1071
    },
    {
      "type": "text",
      "version": 254,
      "versionNonce": 784692217,
      "isDeleted": false,
      "id": "cfEHY3B9KtpKNcJIcSRHQ",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 2340,
      "y": 160,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 380.42578125,
      "height": 45,
      "seed": 1695313766,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1735853184758,
      "link": null,
      "locked": false,
      "fontSize": 36,
      "fontFamily": 5,
      "text": "Possible Deck Interfaces",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "Possible Deck Interfaces",
      "lineHeight": 1.25,
      "baseline": 38
    },
    {
      "type": "text",
      "version": 2665,
      "versionNonce": 561423383,
      "isDeleted": false,
      "id": "dvovSH4J_laKFMWaH8MAY",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 2344.7999877929688,
      "y": 240.3999786376953,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 442.0703125,
      "height": 425,
      "seed": 1574277798,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1735853184758,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 5,
      "text": "Requirements:\n- hold multiple cards\n- can be shuffled\n- cards can be taken/given from the deck \nand the deck updates\n- the deck should adhere to the standard set of 52\n- Should not have duplicate if one pack is used\n- no jokers\n\ninterface Deck {\n    cards: Card[]\n    shuffle: () => void\n    giveCard: () => void\n    validDeck: boolean\n    isDeckValid: () => boolean\n }\n",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "Requirements:\n- hold multiple cards\n- can be shuffled\n- cards can be taken/given from the deck \nand the deck updates\n- the deck should adhere to the standard set of 52\n- Should not have duplicate if one pack is used\n- no jokers\n\ninterface Deck {\n    cards: Card[]\n    shuffle: () => void\n    giveCard: () => void\n    validDeck: boolean\n    isDeckValid: () => boolean\n }\n",
      "lineHeight": 1.25,
      "baseline": 421
    },
    {
      "type": "text",
      "version": 323,
      "versionNonce": 1371966681,
      "isDeleted": false,
      "id": "fMoShbw9weaWv5p-ZkhRi",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 260,
      "y": 1780,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 687.12890625,
      "height": 45,
      "seed": 1309555225,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1735853184758,
      "link": null,
      "locked": false,
      "fontSize": 36,
      "fontFamily": 5,
      "text": "Possible Flow of the game and key function",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "Possible Flow of the game and key function",
      "lineHeight": 1.25,
      "baseline": 38
    },
    {
      "type": "text",
      "version": 4142,
      "versionNonce": 584405497,
      "isDeleted": false,
      "id": "OVRiFB36Mt-Y1teKHs9ny",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 260,
      "y": 1860,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 845.400390625,
      "height": 1400,
      "seed": 877760249,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1735853303521,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 5,
      "text": "1. const [game, setGame] = useState<BlackjackGame>(new BlackjackGame()). UseEffect\nlooking out for change in currentPlayer. Initially undefined. game.startGame() will set up \nall required entities in the game including setting a current player.\n\n2. If currentPlayer is equal to your id, then the hit & stand button will be enabled. Pressing\neither button will execute a sequence will call nextPlayer() once the sequence is complete\n\n3. Everytime NextPlayer() is called the useEffect will check if the current player is AI or the Dealer\n(always AI but plays different). An AI player execute a Hit or Stand based on a probabillity. The \ncloser its score is to 21, the less likely it will hit and vice versa. Automate AI plays also end in\nNextPlayer() being called. UseState will also store the data on currentPlayer etc. \n\n4. Cycle through all player then automate the Dealer plays. Always abides by the same rules.\nNeed to determine whether the dealer will hit on soft 17\n\n5. After dealer sequence ends, call gameOver(), calculate outcomes for each player and display\non the screen. Everyone can see each other outcome\n\nfunction nextPlayer(){\n    game.nextPlayer()\n    setCurrentPlayer(game.currentPlayer)\n    if (game.currentPlayer.isDealer){\n        // Dealer Sequence Function\n    } else if (game.currentPlayer.isAI){\n        // AI Play Sequence Function\n    }\n    // else it is a real player, so we wait till they play\n}\n\nfunction hit(){\n    currentPlayer.hit()\n    nextPlayer()\n}\n\nfunction stand(){ // basically the same as nextPlayer()\n    currentPlayer.evaluate() // not sure if needed\n    nextPlayer()\n}\n\nfunction automatePlayerSequence(){\n    const hit: boolean = probFunction()\n    if (hit){\n        hit()\n    } else {\n        stand()\n    }\n}\n\nfunction automateDealerSequence(){\n    currentPlayer.dealerPlay()\n    nextPlayer()\n}\n\nuseEffect(() => {\n   //check for game over\n}, [currentPlayer])",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "1. const [game, setGame] = useState<BlackjackGame>(new BlackjackGame()). UseEffect\nlooking out for change in currentPlayer. Initially undefined. game.startGame() will set up \nall required entities in the game including setting a current player.\n\n2. If currentPlayer is equal to your id, then the hit & stand button will be enabled. Pressing\neither button will execute a sequence will call nextPlayer() once the sequence is complete\n\n3. Everytime NextPlayer() is called the useEffect will check if the current player is AI or the Dealer\n(always AI but plays different). An AI player execute a Hit or Stand based on a probabillity. The \ncloser its score is to 21, the less likely it will hit and vice versa. Automate AI plays also end in\nNextPlayer() being called. UseState will also store the data on currentPlayer etc. \n\n4. Cycle through all player then automate the Dealer plays. Always abides by the same rules.\nNeed to determine whether the dealer will hit on soft 17\n\n5. After dealer sequence ends, call gameOver(), calculate outcomes for each player and display\non the screen. Everyone can see each other outcome\n\nfunction nextPlayer(){\n    game.nextPlayer()\n    setCurrentPlayer(game.currentPlayer)\n    if (game.currentPlayer.isDealer){\n        // Dealer Sequence Function\n    } else if (game.currentPlayer.isAI){\n        // AI Play Sequence Function\n    }\n    // else it is a real player, so we wait till they play\n}\n\nfunction hit(){\n    currentPlayer.hit()\n    nextPlayer()\n}\n\nfunction stand(){ // basically the same as nextPlayer()\n    currentPlayer.evaluate() // not sure if needed\n    nextPlayer()\n}\n\nfunction automatePlayerSequence(){\n    const hit: boolean = probFunction()\n    if (hit){\n        hit()\n    } else {\n        stand()\n    }\n}\n\nfunction automateDealerSequence(){\n    currentPlayer.dealerPlay()\n    nextPlayer()\n}\n\nuseEffect(() => {\n   //check for game over\n}, [currentPlayer])",
      "lineHeight": 1.25,
      "baseline": 1396
    }
  ],
  "appState": {
    "gridSize": 20,
    "viewBackgroundColor": "#ffffff"
  },
  "files": {}
}